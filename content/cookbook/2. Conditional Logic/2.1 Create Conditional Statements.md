Sometimes, you only want to run logic if a certain thing is true.

UltEvents *really* start to fall apart here, and we'll need to be smart to work around its limitations.

## Checking if two values are Equal

[`object.Equals`](https://learn.microsoft.com/en-us/dotnet/api/system.object.equals?view=net-9.0) is used to check if two values are equal. Update events run every frame. I used one here in play mode to demonstrate this:

![[Attachments/2.1 Create Conditional Statements.md_Attachments/Foo Bar.gif]]
### Side-Quest - Exploiting Debug Mode

Unfortunately, setting this up will not be so simple. Here's a video and breakdown of everything that happened while we set that up:

![[Attachments/2.1 Create Conditional Statements.md_Attachments/Active Based on Name 1.mp4]]

1. I select [`Object.name`](https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Object-name.html) - and switch the mode to get instead of set.
2. I select the static [`object.Equals`](https://learn.microsoft.com/en-us/dotnet/api/system.object.equals?view=net-9.0)  method - used to compare two values.
	1. I hit a limitation - the UltEvents editor forces us to use a return value here.
	2. I overcome this by switching my Editor to Debug mode. This disables the fancy editor and shows us the raw data. Here's what I want, with annotations:
	3. ![[Attachments/2.1 Create Conditional Statements.md_Attachments/2.1 Create Conditional Statements-20250222045430342.png]]
	4. With the above info, I can see that the I need to change call `1`'s argument `1` from a return value to a string, so that I can type 'Foo'. I use debug mode to do this.
	5. I switch out of Debug mode.
	6. I add the final call - Enable the `IsFoo?` GameObject based on if the name of our other object is 'Foo'. 

## Checking if two Values are Unequal

Similarly, to check if two values are *not* equal, you can use another equals method to invert your logic.

![[Attachments/2.1 Create Conditional Statements.md_Attachments/Unity_EM5aQwgxUP.gif]]